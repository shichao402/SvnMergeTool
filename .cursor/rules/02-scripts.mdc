---
alwaysApply: true
---
# 脚本规则 - 最高优先级

## 核心约束（强制）

1. **所有调试操作必须使用项目中已有的脚本**，禁止手动执行命令
2. 如果脚本无法完成工作，**必须修改脚本**使其正常工作
3. AI必须主动执行脚本，不要求用户操作

## 脚本设计原则（指导性）

### 1. 模块化设计

- **原则：** 脚本应该尽量模块化，每个脚本负责单一职责
- **目标：** 提高脚本的可维护性和可复用性
- **实践：** 将复杂的操作拆分为多个独立的脚本模块

### 2. 单点可复用

- **原则：** 功能应该是单点可复用的，避免重复编写相同逻辑
- **示例：** 
  - 部署脚本应该**调用**构建脚本，而不是重复编写构建逻辑
  - 构建脚本应该**调用**清理脚本，而不是重复编写清理逻辑
  - 启动脚本应该**调用**部署脚本，而不是重复编写部署逻辑
- **目标：** 确保每个功能只在一个地方实现，便于维护和更新
- **实践：** 
  ```bash
  # ✅ 好的做法 - 部署脚本调用其他脚本
  ./scripts/build.sh
  ./scripts/deploy.sh
  ./scripts/start.sh
  
  # ❌ 不好的做法 - 在部署脚本中重复编写构建逻辑
  # 直接在 deploy.sh 中写 flutter build apk 等命令
  ```

### 3. 通用和跨平台化

- **原则：** 脚本要考虑通用性和跨平台兼容性
- **目标：** 确保脚本在不同环境下都能正常工作
- **实践：**
  - 使用跨平台的命令和工具
  - 避免硬编码路径，使用环境变量或配置文件
  - 检测操作系统类型，提供不同平台的实现
  - 提供清晰的错误信息和失败处理
  ```bash
  # ✅ 好的做法 - 跨平台路径处理
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  
  # ✅ 好的做法 - 检测操作系统
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
      # Linux specific
  elif [[ "$OSTYPE" == "darwin"* ]]; then
      # macOS specific
  elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
      # Windows specific
  fi
  ```

## 部署脚本

**部署脚本：** `scripts/deploy.sh`

此脚本用于部署Flutter应用到目标平台。AI必须使用此脚本进行部署，不得手动执行flutter命令。

**脚本功能：**
- 自动检测连接的设备
- 构建应用
- 安装到设备
- 启动应用

## 禁止行为

- ❌ 手动查找Flutter CLI路径
- ❌ 手动执行Flutter CLI命令（build、run、install等）
- ❌ 手动使用系统命令收集日志
- ❌ 手动访问日志文件路径
- ❌ 不使用预置脚本进行任何调试操作
- ❌ 要求用户手动执行命令
- ❌ 绕过脚本直接操作
- ❌ 脚本失败后不使用脚本，改为手动执行命令
- ❌ 要求用户手动修复脚本
- ❌ 跳过脚本直接操作
- ❌ 不修复脚本而使用临时方案

## 必须遵守

- ✅ 所有部署必须使用部署脚本
- ✅ 所有日志收集必须使用日志收集脚本
- ✅ 脚本出现问题必须立即修复
- ✅ 修复脚本是AI的责任，不得推给用户
- ✅ 修复后的脚本必须能够正常完成预期功能
- ✅ 修复脚本后必须验证脚本能够正常工作
- ✅ 保持脚本的健壮性和可维护性
- ✅ AI必须主动执行脚本，不要求用户操作

## 脚本维护规则（强制）

**如果预置脚本无法完成工作，必须修改脚本使其符合预期正常工作。**

### 脚本问题处理流程

1. **发现问题：** 当脚本执行失败或无法完成预期功能时
2. **分析问题：** 检查脚本错误信息，定位问题原因
3. **修复脚本：** 直接修改脚本文件，使其能够正常工作
4. **验证修复：** 重新执行脚本，确保问题已解决
5. **继续工作：** 使用修复后的脚本继续完成调试任务
