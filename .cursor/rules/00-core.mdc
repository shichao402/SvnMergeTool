---
alwaysApply: true
---
# SvnMergeTool 项目核心规则

## 规则优先级

1. **最高优先级：** 文档管理规则、日志规则、脚本规则、调试规则
2. **高优先级：** 安全规则、测试流程规则、构建和部署规则、版本管理规则
3. **中优先级：** 开发规则

## 核心原则

1. **文档优先** - 所有文档必须统一管理在 Documents/ 目录，过程性文档放在 temp/ 并添加到 .gitignore
2. **自动化优先** - AI必须主动执行脚本，不要求用户操作
3. **脚本优先** - 禁止手动执行命令，脚本失败必须修复脚本
4. **日志优先** - 所有组件必须先实现日志系统
5. **主动调试** - AI必须主动收集日志，不等待用户提供信息
6. **安全优先** - 所有敏感信息必须被清洗并且排除到版本控制之外
7. **脚手架优先** - 为了简化初始化配置，必须提供初始化脚手架

## 初始化脚手架规则（高优先级）

### 核心约束（强制）

1. **必须提供初始化脚手架**，简化项目初始化配置
2. **脚手架规则根据具体的项目技术选型使用特定的mdc规则处理**
3. AI必须主动使用脚手架进行项目初始化，不要求用户手动配置

### 脚手架设计原则

#### 1. 技术选型适配

- **原则：** 脚手架必须根据项目技术选型（语言、框架、平台）自动应用对应的mdc规则
- **目标：** 确保新项目能够快速获得适合的规则配置
- **实践：** 
  - 检测项目技术栈（如Flutter、React、Python等）
  - 自动选择对应的规则模板（`languages/*.mdc.template`、`frameworks/*.mdc.template`、`platforms/*.mdc.template`）
  - 根据技术选型组合应用多个规则模板

#### 2. 配置简化

- **原则：** 脚手架必须简化初始化配置流程
- **目标：** 减少手动配置步骤，提高初始化效率
- **实践：**
  - 提供交互式配置向导
  - 自动检测项目结构和技术栈
  - 生成必要的配置文件和目录结构
  - 应用预定义的规则模板

#### 3. 规则自动应用

- **原则：** 脚手架必须自动应用对应的mdc规则
- **目标：** 确保项目初始化后立即具备完整的规则体系
- **实践：**
  ```bash
  # 脚手架自动检测技术选型
  # Flutter项目 -> 应用 flutter.mdc.template + dart.mdc.template + android.mdc.template
  # React项目 -> 应用 react.mdc.template + typescript.mdc.template
  # Python项目 -> 应用 python.mdc.template
  ```

### 脚手架功能要求

#### 必须提供的功能

- ✅ **技术栈检测** - 自动识别项目使用的语言、框架、平台
- ✅ **规则模板选择** - 根据技术选型自动选择对应的mdc规则模板
- ✅ **配置文件生成** - 生成必要的配置文件（如 `.cursor/rules/` 目录结构）
- ✅ **规则文件应用** - 将选定的规则模板应用到项目中
- ✅ **初始化验证** - 验证初始化是否成功，规则是否正确应用

#### 可选功能

- 交互式配置向导
- 规则自定义选项
- 初始化后验证和测试

### 禁止行为

- ❌ 要求用户手动选择规则模板
- ❌ 要求用户手动创建配置文件
- ❌ 要求用户手动应用规则
- ❌ 跳过脚手架直接手动配置
- ❌ 不根据技术选型应用规则

### 必须遵守

- ✅ 必须提供初始化脚手架
- ✅ 脚手架必须根据技术选型自动应用对应的mdc规则
- ✅ 脚手架必须简化配置流程
- ✅ AI必须主动使用脚手架进行初始化
- ✅ 初始化后必须验证规则是否正确应用

## 模块化规则注入规则（高优先级）

### 核心约束（强制）

1. **脚手架必须支持在项目使用过程中根据需要运行**
2. **必须支持模块化规则的动态注入**
3. **模块化规则必须根据项目参数和模块参数进行定制**
4. **注入的规则必须与现有规则体系兼容**

### 模块化规则注入流程

#### 1. 模块选择

- **原则：** 脚手架必须提供模块选择功能
- **目标：** 让用户能够选择需要注入的模块化规则
- **实践：**
  ```bash
  # 运行模块注入命令
  python start.py inject <目标项目目录>
  
  # 脚手架会列出可用的模块
  # 用户选择需要的模块（如：更新模块）
  ```

#### 2. 项目参数读取

- **原则：** 脚手架必须读取目标项目的完整参数
- **目标：** 确保通过本脚手架创建的项目能够被正确识别
- **实践：**
  - 读取目标项目的 `.cursor/rules/` 目录中的规则文件
  - 从规则文件中提取项目参数（项目名称、语言、框架等）
  - 验证项目是否由本脚手架创建（检查参数完整性）

#### 3. 模块参数收集

- **原则：** 脚手架必须收集模块特定的参数
- **目标：** 定制模块化规则以适应具体项目
- **实践：**
  - 读取模块配置文件（`module.config.json`）
  - 交互式收集模块参数
  - 验证参数的有效性和完整性

#### 4. 规则定制和注入

- **原则：** 根据项目参数和模块参数定制规则并注入到目标项目
- **目标：** 确保注入的规则与项目现有规则体系兼容
- **实践：**
  - 合并项目参数和模块参数
  - 使用Jinja2模板引擎渲染模块规则模板
  - 将渲染后的规则文件注入到目标项目的 `.cursor/rules/` 目录
  - 确保规则文件命名符合优先级规范

### 模块化规则设计原则

#### 1. 模块独立性

- **原则：** 模块化规则应该相对独立，不破坏现有规则体系
- **目标：** 确保模块可以安全地注入和移除
- **实践：**
  - 模块规则使用独立的文件
  - 模块规则不覆盖现有规则
  - 模块规则可以引用现有规则（如日志规则）

#### 2. 参数化设计

- **原则：** 模块规则必须支持参数化定制
- **目标：** 适应不同项目的具体需求
- **实践：**
  - 使用Jinja2模板语法定义占位符
  - 提供模块配置文件定义参数
  - 支持参数验证和默认值

#### 3. 兼容性检查

- **原则：** 模块规则必须检查与项目的兼容性
- **目标：** 确保模块规则适用于当前项目
- **实践：**
  - 检查项目语言和框架兼容性
  - 检查模块依赖是否满足
  - 验证模块参数是否有效

### 模块化规则存储结构

```
project-init/templates/modules/
├── [module-id]/
│   ├── module.config.json          # 模块配置文件
│   ├── [module-name].mdc.template  # 模块规则模板
│   └── [其他资源文件]
```

### 模块配置文件格式

模块配置文件（`module.config.json`）必须包含：
- `moduleId` - 模块唯一标识
- `moduleName` - 模块名称
- `moduleDescription` - 模块描述
- `moduleType` - 模块类型（feature/utility等）
- `priority` - 规则优先级（用于文件命名）
- `dependencies` - 模块依赖（required/optional）
- `parameters` - 模块参数定义
- `compatibleLanguages` - 兼容的语言列表
- `compatibleFrameworks` - 兼容的框架列表

### 禁止行为

- ❌ 不检查项目参数完整性就注入模块
- ❌ 不验证模块兼容性就注入规则
- ❌ 覆盖现有规则文件
- ❌ 不提供模块参数定制
- ❌ 不验证注入后的规则有效性

### 必须遵守

- ✅ 必须支持模块化规则的动态注入
- ✅ 必须读取目标项目的完整参数
- ✅ 必须收集模块特定参数
- ✅ 必须根据项目参数和模块参数定制规则
- ✅ 必须验证模块兼容性
- ✅ 必须确保注入的规则与现有规则体系兼容
- ✅ 必须使用统一的规则文件命名规范
