---
alwaysApply: true
---
# 脚本规则 - 最高优先级

## 核心约束（强制）

1. **所有调试操作必须使用项目中已有的脚本**，禁止手动执行命令
2. 如果脚本无法完成工作，**必须修改脚本**使其正常工作
3. AI必须主动执行脚本，不要求用户操作
4. **所有脚本必须支持跨平台**，必须提供 Windows、macOS 和 Linux 的入口脚本
5. **临时使用的脚本必须放到 `scripts/temp/` 目录**，并添加到 `.gitignore`
6. **脚本中禁止提供交互操作**（如 `input()`、`Read-Host`、`read` 等），因为脚本需要同时支持人类和AI使用，而AI的交互操作能力很差

## 脚本设计原则（指导性）

### 1. 模块化设计

- **原则：** 脚本应该尽量模块化，每个脚本负责单一职责
- **目标：** 提高脚本的可维护性和可复用性
- **实践：** 将复杂的操作拆分为多个独立的脚本模块

### 2. 单点可复用

- **原则：** 功能应该是单点可复用的，避免重复编写相同逻辑
- **示例：** 
  - 部署脚本应该**调用**构建脚本，而不是重复编写构建逻辑
  - 构建脚本应该**调用**清理脚本，而不是重复编写清理逻辑
  - 启动脚本应该**调用**部署脚本，而不是重复编写部署逻辑
- **目标：** 确保每个功能只在一个地方实现，便于维护和更新
- **实践：** 
  ```bash
  # ✅ 好的做法 - 部署脚本调用其他脚本
  ./scripts/build.sh
  ./scripts/deploy.sh
  ./scripts/start.sh
  
  # ❌ 不好的做法 - 在部署脚本中重复编写构建逻辑
  # 直接在 deploy.sh 中写 flutter build apk 等命令
  ```

### 3. 跨平台支持（强制）

- **原则：** 所有脚本必须支持跨平台，核心逻辑必须使用跨平台语言实现
- **目标：** 确保脚本在 Windows、macOS 和 Linux 上都能正常工作
- **实现方式：**
  - **必须：** 使用跨平台语言（如 Python）实现核心逻辑
  - **入口脚本：** 各平台提供简单的代理入口脚本（.bat/.sh），仅用于调用核心 Python 脚本
  - **禁止：** 在入口脚本中编写业务逻辑，所有业务逻辑必须在 Python 核心脚本中实现

### 4. 路径处理规则（强制）

- **原则：** 必须使用标准的跨平台路径处理方法，严禁使用平台特定的路径操作
- **目标：** 确保脚本在所有平台上都能正确处理路径
- **实践：**
  - **Python 脚本：** 必须使用 `pathlib.Path` 处理所有路径
  - **路径拼接：** 使用 `Path.joinpath()` 或 `/` 操作符，严禁手动拼装 `/` 或 `\`
  - **路径解析：** 使用 `Path.resolve()`、`Path.parent`、`Path.name` 等方法
  - **绝对路径：** 使用 `Path.resolve()` 或 `Path.absolute()`，严禁手动处理盘符或 `/` 前缀
  - **路径比较：** 使用 `Path.samefile()` 或转换为字符串后比较，严禁直接比较路径对象

**禁止的路径操作：**
```python
# ❌ 错误：手动拼装路径分隔符
path = base_dir + "\\subdir\\file.txt"  # Windows 特定
path = base_dir + "/subdir/file.txt"     # Unix 特定
path = base_dir + os.sep + "subdir"      # 虽然使用 os.sep，但字符串拼接不推荐

# ❌ 错误：手动处理盘符
if path.startswith("C:\\"):              # Windows 特定
if path.startswith("/"):                 # Unix 特定

# ❌ 错误：使用字符串方法处理路径
path = path.replace("\\", "/")           # 不推荐，应使用 pathlib

# ✅ 正确：使用 pathlib.Path
from pathlib import Path
path = Path(base_dir) / "subdir" / "file.txt"  # 跨平台
path = Path(base_dir).joinpath("subdir", "file.txt")  # 跨平台
```

**路径处理最佳实践：**
```python
from pathlib import Path

# 获取脚本所在目录
script_dir = Path(__file__).parent.resolve()

# 获取项目根目录
project_root = script_dir.parent

# 拼接路径
config_file = project_root / "config" / "app.json"
log_dir = project_root / "logs"

# 检查路径是否存在
if config_file.exists():
    # 读取文件
    content = config_file.read_text(encoding='utf-8')

# 创建目录
log_dir.mkdir(parents=True, exist_ok=True)

# 获取路径的各个部分
file_name = config_file.name           # "app.json"
file_stem = config_file.stem           # "app"
file_suffix = config_file.suffix        # ".json"
parent_dir = config_file.parent        # Path("config")
```

#### 平台代理入口脚本模式（必须）

**核心实现：** 必须使用 Python 等跨平台语言实现核心逻辑
**入口脚本：** 各平台提供简单的代理脚本调用核心实现，入口脚本不包含业务逻辑

**目录结构：**
```
scripts/
├── build.py              # 核心实现（Python，跨平台）
├── build.sh              # macOS/Linux 入口脚本
├── build.bat             # Windows 入口脚本
├── deploy.py             # 核心实现
├── deploy.sh             # macOS/Linux 入口脚本
└── deploy.bat            # Windows 入口脚本
```

**Windows 入口脚本示例（build.bat）：**
```batch
@echo off
REM 获取脚本所在目录
set SCRIPT_DIR=%~dp0
REM 使用虚拟环境的 Python 运行核心脚本
"%SCRIPT_DIR%..venv\Scripts\python.exe" "%SCRIPT_DIR%build.py" %*
```

**macOS/Linux 入口脚本示例（build.sh）：**
```bash
#!/bin/bash
# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# 使用虚拟环境的 Python 运行核心脚本
exec "$SCRIPT_DIR/../.venv/bin/python" "$SCRIPT_DIR/build.py" "$@"
```

**核心脚本示例（build.py）：**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
跨平台构建脚本
"""
import sys
from pathlib import Path

def main():
    # ✅ 正确：使用 pathlib.Path 处理路径
    script_dir = Path(__file__).parent.resolve()
    project_root = script_dir.parent
    config_file = project_root / "config" / "app.json"  # 使用 / 操作符
    
    # ❌ 错误：手动拼装路径分隔符
    # config_file = project_root + "\\config\\app.json"  # Windows 特定
    # config_file = project_root + "/config/app.json"     # Unix 特定
    
    # ❌ 错误：手动处理盘符或绝对路径
    # if path.startswith("C:\\"):  # Windows 特定
    # if path.startswith("/"):     # Unix 特定
    
    # 跨平台命令执行
    # ... 构建逻辑 ...
    pass

if __name__ == '__main__':
    main()
```

#### 入口脚本要求

**入口脚本必须：**
- 仅用于调用核心 Python 脚本
- 不包含任何业务逻辑
- 不包含平台特定的命令或操作
- 只负责定位 Python 解释器和传递参数

**入口脚本禁止：**
- ❌ 在入口脚本中编写业务逻辑
- ❌ 使用平台特定的命令（如 `flutter build`、`npm install` 等）
- ❌ 处理文件路径或执行文件操作
- ❌ 包含条件判断或复杂逻辑

**正确的入口脚本示例：**

```batch
REM Windows 入口脚本（build.bat）- 仅调用 Python
@echo off
set "SCRIPT_DIR=%~dp0"
if exist "%SCRIPT_DIR%..\.venv\Scripts\python.exe" (
    "%SCRIPT_DIR%..\.venv\Scripts\python.exe" "%SCRIPT_DIR%build.py" %*
) else (
    python "%SCRIPT_DIR%build.py" %*
)
```

```bash
#!/bin/bash
# macOS/Linux 入口脚本（build.sh）- 仅调用 Python
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/../.venv/bin/python" ]; then
    exec "$SCRIPT_DIR/../.venv/bin/python" "$SCRIPT_DIR/build.py" "$@"
else
    exec python3 "$SCRIPT_DIR/build.py" "$@"
fi
```

### 4. 脚本目录组织（强制）

- **原则：** 脚本必须按用途分类组织，临时脚本必须单独存放
- **目标：** 保持脚本目录清晰，区分正式脚本和临时脚本
- **目录结构：**
  ```
  scripts/
  ├── build.py              # 正式脚本
  ├── build.sh
  ├── build.bat
  ├── deploy.py
  ├── deploy.sh
  ├── deploy.bat
  ├── lib/                   # 脚本库（可复用模块）
  │   └── version_manager.py
  └── temp/                  # 临时脚本目录（不提交到版本控制）
      ├── .gitkeep           # 保持目录存在
      └── debug_xxx.py       # 临时调试脚本
  ```

#### 临时脚本规则

**临时脚本定义：**
- 用于一次性调试或测试的脚本
- 用于临时解决特定问题的脚本
- 用于实验性功能的脚本
- 不确定是否需要长期保留的脚本

**临时脚本存放规则：**
- ✅ **必须放在 `scripts/temp/` 目录**
- ✅ **必须添加到 `.gitignore`**，不提交到版本控制
- ✅ 临时脚本使用完毕后，应该及时清理
- ✅ 如果临时脚本需要长期使用，应该移动到正式脚本目录

**示例：**
```bash
# ✅ 正确 - 临时调试脚本放在 temp 目录
scripts/temp/debug_build_issue.py
scripts/temp/test_new_feature.sh
scripts/temp/experimental_deploy.bat

# ❌ 错误 - 临时脚本放在 scripts 根目录
scripts/debug_build_issue.py
scripts/test_new_feature.sh
```

**`.gitignore` 配置：**
```
# 临时脚本目录
scripts/temp/*
!scripts/temp/.gitkeep
```

### 5. 非交互式设计（强制）

- **原则：** 所有脚本必须完全非交互式，禁止任何形式的用户交互操作
- **原因：** 脚本需要同时支持人类和AI使用，而AI的交互操作能力很差，无法处理交互式输入
- **目标：** 确保脚本可以被AI自动执行，无需人工干预

#### 禁止的交互操作

**Python：**
- ❌ `input()` - 等待用户输入
- ❌ `raw_input()` - 等待用户输入（Python 2）
- ❌ 任何需要键盘输入的操作

**PowerShell：**
- ❌ `Read-Host` - 等待用户输入
- ❌ `$host.UI.PromptForChoice()` - 交互式选择
- ❌ 任何需要键盘输入的操作

**Bash/Shell：**
- ❌ `read` - 等待用户输入
- ❌ `read -p` - 提示并等待用户输入
- ❌ `select` - 交互式选择菜单
- ❌ 任何需要键盘输入的操作

**Batch：**
- ❌ `set /p` - 等待用户输入
- ❌ `pause` - 等待用户按键（除非用于调试）
- ❌ 任何需要键盘输入的操作

#### 替代方案

**使用命令行参数：**
```python
# ✅ 好的做法 - 使用命令行参数
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--version', required=True, help='版本号')
args = parser.parse_args()
version = args.version

# ❌ 不好的做法 - 使用交互式输入
version = input("请输入版本号: ")
```

**使用环境变量：**
```bash
# ✅ 好的做法 - 使用环境变量
VERSION=${VERSION:-"1.0.0"}  # 提供默认值
echo "版本号: $VERSION"

# ❌ 不好的做法 - 使用交互式输入
read -p "请输入版本号: " VERSION
```

**使用配置文件：**
```python
# ✅ 好的做法 - 使用配置文件
import json
with open('config.json') as f:
    config = json.load(f)
version = config['version']

# ❌ 不好的做法 - 使用交互式输入
version = input("请输入版本号: ")
```

**使用默认值：**
```python
# ✅ 好的做法 - 提供默认值
version = os.getenv('VERSION', '1.0.0')  # 从环境变量读取，否则使用默认值

# ❌ 不好的做法 - 必须用户输入
version = input("请输入版本号: ")  # 没有默认值，必须输入
```

#### 错误处理

脚本应该优雅地处理缺少参数的情况，而不是等待用户输入：

```python
# ✅ 好的做法 - 优雅处理缺少参数
import sys
if len(sys.argv) < 2:
    print("错误: 缺少版本号参数")
    print("用法: python script.py <version>")
    sys.exit(1)
version = sys.argv[1]

# ❌ 不好的做法 - 等待用户输入
if len(sys.argv) < 2:
    version = input("请输入版本号: ")  # AI无法处理
else:
    version = sys.argv[1]
```

## 部署脚本

**部署脚本：** `scripts/deploy.sh`

此脚本用于部署Flutter应用到目标平台。AI必须使用此脚本进行部署，不得手动执行flutter命令。

**脚本功能：**
- 自动检测连接的设备
- 构建应用
- 安装到设备
- 启动应用

## 脚本日志输出规范（强制）

### 核心原则

1. **所有脚本必须输出文件日志**：脚本执行过程和结果必须写入日志文件
2. **AI 必须通过日志文件判断执行结果**：禁止仅依赖标准输出判断脚本是否成功
3. **日志文件路径必须可预测**：通过文档或约定确定日志文件位置

### 为什么需要文件日志

- **标准输出不可靠**：终端缓冲、管道截断、历史命令混入等问题会导致标准输出内容不准确
- **可追溯性**：文件日志可以保留完整的执行历史，便于问题排查
- **AI 判断依据**：AI 必须有明确、可靠的依据来判断脚本执行结果

### 日志文件规范

**日志目录：** `logs/scripts/`

**日志文件命名：** `{脚本名}_{时间戳}.log`
- 示例：`deploy_20241215_143052.log`
- 时间戳格式：`YYYYMMDD_HHMMSS`

**最新日志软链接：** `{脚本名}_latest.log`
- 每次执行后更新，指向最新的日志文件
- AI 应优先读取此文件获取最新执行结果

**日志内容必须包含：**
```
[时间戳] [级别] 消息内容

必须记录：
- 脚本开始执行时间
- 关键步骤的开始和完成
- 命令执行结果（成功/失败）
- 错误信息和堆栈（如有）
- 脚本执行结果（SUCCESS/FAILED）
- 脚本结束时间和总耗时
```

**日志级别：**
- `INFO`：正常信息
- `WARN`：警告信息
- `ERROR`：错误信息
- `DEBUG`：调试信息（可选）

### 日志输出示例

```
[2024-12-15 14:30:52] [INFO] ========== 部署脚本开始执行 ==========
[2024-12-15 14:30:52] [INFO] 平台: macOS
[2024-12-15 14:30:52] [INFO] 目标: release
[2024-12-15 14:30:53] [INFO] 步骤 1/3: 清理构建目录
[2024-12-15 14:30:55] [INFO] 步骤 1/3: 完成
[2024-12-15 14:30:55] [INFO] 步骤 2/3: 构建应用
[2024-12-15 14:32:10] [INFO] 步骤 2/3: 完成
[2024-12-15 14:32:10] [INFO] 步骤 3/3: 启动应用
[2024-12-15 14:32:12] [INFO] 步骤 3/3: 完成
[2024-12-15 14:32:12] [INFO] ========== 部署脚本执行完成 ==========
[2024-12-15 14:32:12] [INFO] 结果: SUCCESS
[2024-12-15 14:32:12] [INFO] 耗时: 80 秒
[2024-12-15 14:32:12] [INFO] 产物: build/macos/Build/Products/Release/SvnMergeTool.app
```

### AI 使用脚本的流程（强制）

1. **执行脚本**：运行脚本命令
2. **读取日志文件**：读取 `logs/scripts/{脚本名}_latest.log`
3. **判断执行结果**：根据日志中的 `结果: SUCCESS/FAILED` 判断
4. **如果失败**：分析日志中的错误信息，修复问题后重新执行

**禁止行为：**
- ❌ 仅通过标准输出判断脚本是否成功
- ❌ 通过 `grep` 标准输出来查找错误
- ❌ 假设标准输出完整且准确

### Python 日志工具类

脚本应使用统一的日志工具类，位于 `scripts/lib/script_logger.py`：

```python
from pathlib import Path
from datetime import datetime

class ScriptLogger:
    def __init__(self, script_name: str):
        self.script_name = script_name
        self.log_dir = Path(__file__).parent.parent.parent / "logs" / "scripts"
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_file = self.log_dir / f"{script_name}_{timestamp}.log"
        self.latest_link = self.log_dir / f"{script_name}_latest.log"
        
        # 更新最新日志链接
        if self.latest_link.exists():
            self.latest_link.unlink()
        self.latest_link.symlink_to(self.log_file.name)
    
    def _log(self, level: str, message: str):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        line = f"[{timestamp}] [{level}] {message}"
        print(line)  # 同时输出到标准输出
        with open(self.log_file, "a", encoding="utf-8") as f:
            f.write(line + "\n")
    
    def info(self, message: str):
        self._log("INFO", message)
    
    def warn(self, message: str):
        self._log("WARN", message)
    
    def error(self, message: str):
        self._log("ERROR", message)
    
    def success(self):
        self.info("结果: SUCCESS")
    
    def failed(self, reason: str = ""):
        self.error(f"结果: FAILED - {reason}" if reason else "结果: FAILED")
```

## 禁止行为

- ❌ 手动查找Flutter CLI路径
- ❌ 手动执行Flutter CLI命令（build、run、install等）
- ❌ 手动使用系统命令收集日志
- ❌ 手动访问日志文件路径
- ❌ 不使用预置脚本进行任何调试操作
- ❌ 要求用户手动执行命令
- ❌ 绕过脚本直接操作
- ❌ 脚本失败后不使用脚本，改为手动执行命令
- ❌ 要求用户手动修复脚本
- ❌ 跳过脚本直接操作
- ❌ 不修复脚本而使用临时方案
- ❌ **只提供单一平台的脚本**（必须支持 Windows、macOS、Linux）
- ❌ **使用平台特定的脚本语言编写业务逻辑**（如批处理、Shell 脚本中的业务逻辑）
- ❌ **在入口脚本中编写业务逻辑**（入口脚本只能调用 Python 核心脚本）
- ❌ **使用平台特定的命令而不提供跨平台实现**
- ❌ **硬编码平台特定的路径或命令**
- ❌ **将临时脚本放在 `scripts/` 根目录**（必须放在 `scripts/temp/` 目录）
- ❌ **将临时脚本提交到版本控制**（必须添加到 `.gitignore`）
- ❌ **在脚本中使用交互操作**（如 `input()`、`Read-Host`、`read` 等）
- ❌ **要求用户手动输入参数**（应使用命令行参数、环境变量或配置文件）
- ❌ **使用 `pause`、`select` 等交互式命令**（除非用于调试且可跳过）
- ❌ **手动拼装路径分隔符**（`/` 或 `\`），必须使用 `pathlib.Path`
- ❌ **手动处理盘符或绝对路径前缀**（如 `C:\` 或 `/`），必须使用 `Path.resolve()`
- ❌ **使用字符串拼接或替换处理路径**，必须使用 `pathlib.Path` 的方法
- ❌ **在 Python 脚本中使用 `os.path.join()`**（虽然跨平台，但推荐使用 `pathlib.Path`）

## 必须遵守

- ✅ 所有部署必须使用部署脚本
- ✅ 所有日志收集必须使用日志收集脚本
- ✅ 脚本出现问题必须立即修复
- ✅ 修复脚本是AI的责任，不得推给用户
- ✅ 修复后的脚本必须能够正常完成预期功能
- ✅ 修复脚本后必须验证脚本能够正常工作
- ✅ 保持脚本的健壮性和可维护性
- ✅ AI必须主动执行脚本，不要求用户操作
- ✅ **所有脚本必须提供跨平台支持**（Windows、macOS、Linux）
- ✅ **核心逻辑必须使用跨平台语言（Python）实现**，严禁使用平台特定的脚本语言编写业务逻辑
- ✅ **必须提供各平台的入口脚本**（.bat 用于 Windows，.sh 用于 macOS/Linux），但入口脚本仅用于调用 Python 核心脚本
- ✅ **入口脚本必须保持简单**，只负责定位 Python 解释器和传递参数，不包含任何业务逻辑
- ✅ **临时脚本必须放在 `scripts/temp/` 目录**，并添加到 `.gitignore`
- ✅ **临时脚本使用完毕后应该及时清理**，如需长期使用应移动到正式脚本目录
- ✅ **所有脚本必须完全非交互式**，使用命令行参数、环境变量或配置文件获取输入
- ✅ **脚本必须提供默认值或清晰的错误提示**，而不是等待用户输入
- ✅ **脚本必须可以被AI自动执行**，无需任何人工干预
- ✅ **Python 脚本必须使用 `pathlib.Path` 处理所有路径**，严禁手动拼装路径
- ✅ **路径拼接必须使用 `Path.joinpath()` 或 `/` 操作符**，严禁使用字符串拼接
- ✅ **路径解析必须使用 `Path.resolve()`、`Path.parent` 等方法**，严禁手动处理
- ✅ **所有路径操作必须通过 `pathlib.Path` 的方法完成**，确保跨平台兼容性

## 脚本维护规则（强制）

**如果预置脚本无法完成工作，必须修改脚本使其符合预期正常工作。**

### 脚本问题处理流程

1. **发现问题：** 当脚本执行失败或无法完成预期功能时
2. **分析问题：** 检查脚本错误信息，定位问题原因
3. **修复脚本：** 直接修改脚本文件，使其能够正常工作
4. **验证修复：** 重新执行脚本，确保问题已解决
5. **继续工作：** 使用修复后的脚本继续完成调试任务
