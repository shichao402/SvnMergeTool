---
alwaysApply: true
---
# 脚本规则 - 最高优先级

## 核心约束（强制）

1. **所有调试操作必须使用项目中已有的脚本**，禁止手动执行命令
2. 如果脚本无法完成工作，**必须修改脚本**使其正常工作
3. AI必须主动执行脚本，不要求用户操作
4. **所有脚本必须支持跨平台**，必须提供 Windows、macOS 和 Linux 的入口脚本
5. **临时使用的脚本必须放到 `scripts/temp/` 目录**，并添加到 `.gitignore`
6. **脚本中禁止提供交互操作**（如 `input()`、`Read-Host`、`read` 等），因为脚本需要同时支持人类和AI使用，而AI的交互操作能力很差

## 脚本设计原则（指导性）

### 1. 模块化设计

- **原则：** 脚本应该尽量模块化，每个脚本负责单一职责
- **目标：** 提高脚本的可维护性和可复用性
- **实践：** 将复杂的操作拆分为多个独立的脚本模块

### 2. 单点可复用

- **原则：** 功能应该是单点可复用的，避免重复编写相同逻辑
- **示例：** 
  - 部署脚本应该**调用**构建脚本，而不是重复编写构建逻辑
  - 构建脚本应该**调用**清理脚本，而不是重复编写清理逻辑
  - 启动脚本应该**调用**部署脚本，而不是重复编写部署逻辑
- **目标：** 确保每个功能只在一个地方实现，便于维护和更新
- **实践：** 
  ```bash
  # ✅ 好的做法 - 部署脚本调用其他脚本
  ./scripts/build.sh
  ./scripts/deploy.sh
  ./scripts/start.sh
  
  # ❌ 不好的做法 - 在部署脚本中重复编写构建逻辑
  # 直接在 deploy.sh 中写 flutter build apk 等命令
  ```

### 3. 跨平台支持（强制）

- **原则：** 所有脚本必须支持跨平台，提供各平台的入口脚本
- **目标：** 确保脚本在 Windows、macOS 和 Linux 上都能正常工作
- **实现方式：**
  - **推荐：** 使用跨平台语言（如 Python）实现核心逻辑，各平台提供代理入口脚本
  - **备选：** 使用平台特定的脚本语言，但必须提供所有平台的版本

#### 平台代理入口脚本模式（推荐）

**核心实现：** 使用 Python 等跨平台语言实现核心逻辑
**入口脚本：** 各平台提供简单的代理脚本调用核心实现

**目录结构：**
```
scripts/
├── build.py              # 核心实现（Python，跨平台）
├── build.sh              # macOS/Linux 入口脚本
├── build.bat             # Windows 入口脚本
├── deploy.py             # 核心实现
├── deploy.sh             # macOS/Linux 入口脚本
└── deploy.bat            # Windows 入口脚本
```

**Windows 入口脚本示例（build.bat）：**
```batch
@echo off
REM 获取脚本所在目录
set SCRIPT_DIR=%~dp0
REM 使用虚拟环境的 Python 运行核心脚本
"%SCRIPT_DIR%..venv\Scripts\python.exe" "%SCRIPT_DIR%build.py" %*
```

**macOS/Linux 入口脚本示例（build.sh）：**
```bash
#!/bin/bash
# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# 使用虚拟环境的 Python 运行核心脚本
exec "$SCRIPT_DIR/../.venv/bin/python" "$SCRIPT_DIR/build.py" "$@"
```

**核心脚本示例（build.py）：**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
跨平台构建脚本
"""
import sys
from pathlib import Path

def main():
    # 跨平台路径处理
    script_dir = Path(__file__).parent.resolve()
    project_root = script_dir.parent
    
    # 跨平台命令执行
    # ... 构建逻辑 ...
    pass

if __name__ == '__main__':
    main()
```

#### 纯脚本语言模式（备选）

如果使用纯脚本语言，必须提供所有平台的版本：

**Windows 批处理脚本（build.bat）：**
```batch
@echo off
setlocal
set SCRIPT_DIR=%~dp0
cd /d "%SCRIPT_DIR%.."
REM Windows 特定的构建命令
flutter build apk
```

**macOS/Linux Shell 脚本（build.sh）：**
```bash
#!/bin/bash
set -e
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR/.."
# Unix 特定的构建命令
flutter build apk
```

#### 跨平台路径处理

无论使用哪种模式，都必须正确处理跨平台路径：

```python
# Python - 跨平台路径处理
from pathlib import Path
script_dir = Path(__file__).parent.resolve()
project_root = script_dir.parent
```

```bash
# Shell - Unix 路径处理
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
```

```batch
REM Batch - Windows 路径处理
set SCRIPT_DIR=%~dp0
```

### 4. 脚本目录组织（强制）

- **原则：** 脚本必须按用途分类组织，临时脚本必须单独存放
- **目标：** 保持脚本目录清晰，区分正式脚本和临时脚本
- **目录结构：**
  ```
  scripts/
  ├── build.py              # 正式脚本
  ├── build.sh
  ├── build.bat
  ├── deploy.py
  ├── deploy.sh
  ├── deploy.bat
  ├── lib/                   # 脚本库（可复用模块）
  │   └── version_manager.py
  └── temp/                  # 临时脚本目录（不提交到版本控制）
      ├── .gitkeep           # 保持目录存在
      └── debug_xxx.py       # 临时调试脚本
  ```

#### 临时脚本规则

**临时脚本定义：**
- 用于一次性调试或测试的脚本
- 用于临时解决特定问题的脚本
- 用于实验性功能的脚本
- 不确定是否需要长期保留的脚本

**临时脚本存放规则：**
- ✅ **必须放在 `scripts/temp/` 目录**
- ✅ **必须添加到 `.gitignore`**，不提交到版本控制
- ✅ 临时脚本使用完毕后，应该及时清理
- ✅ 如果临时脚本需要长期使用，应该移动到正式脚本目录

**示例：**
```bash
# ✅ 正确 - 临时调试脚本放在 temp 目录
scripts/temp/debug_build_issue.py
scripts/temp/test_new_feature.sh
scripts/temp/experimental_deploy.bat

# ❌ 错误 - 临时脚本放在 scripts 根目录
scripts/debug_build_issue.py
scripts/test_new_feature.sh
```

**`.gitignore` 配置：**
```
# 临时脚本目录
scripts/temp/*
!scripts/temp/.gitkeep
```

### 5. 非交互式设计（强制）

- **原则：** 所有脚本必须完全非交互式，禁止任何形式的用户交互操作
- **原因：** 脚本需要同时支持人类和AI使用，而AI的交互操作能力很差，无法处理交互式输入
- **目标：** 确保脚本可以被AI自动执行，无需人工干预

#### 禁止的交互操作

**Python：**
- ❌ `input()` - 等待用户输入
- ❌ `raw_input()` - 等待用户输入（Python 2）
- ❌ 任何需要键盘输入的操作

**PowerShell：**
- ❌ `Read-Host` - 等待用户输入
- ❌ `$host.UI.PromptForChoice()` - 交互式选择
- ❌ 任何需要键盘输入的操作

**Bash/Shell：**
- ❌ `read` - 等待用户输入
- ❌ `read -p` - 提示并等待用户输入
- ❌ `select` - 交互式选择菜单
- ❌ 任何需要键盘输入的操作

**Batch：**
- ❌ `set /p` - 等待用户输入
- ❌ `pause` - 等待用户按键（除非用于调试）
- ❌ 任何需要键盘输入的操作

#### 替代方案

**使用命令行参数：**
```python
# ✅ 好的做法 - 使用命令行参数
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--version', required=True, help='版本号')
args = parser.parse_args()
version = args.version

# ❌ 不好的做法 - 使用交互式输入
version = input("请输入版本号: ")
```

**使用环境变量：**
```bash
# ✅ 好的做法 - 使用环境变量
VERSION=${VERSION:-"1.0.0"}  # 提供默认值
echo "版本号: $VERSION"

# ❌ 不好的做法 - 使用交互式输入
read -p "请输入版本号: " VERSION
```

**使用配置文件：**
```python
# ✅ 好的做法 - 使用配置文件
import json
with open('config.json') as f:
    config = json.load(f)
version = config['version']

# ❌ 不好的做法 - 使用交互式输入
version = input("请输入版本号: ")
```

**使用默认值：**
```python
# ✅ 好的做法 - 提供默认值
version = os.getenv('VERSION', '1.0.0')  # 从环境变量读取，否则使用默认值

# ❌ 不好的做法 - 必须用户输入
version = input("请输入版本号: ")  # 没有默认值，必须输入
```

#### 错误处理

脚本应该优雅地处理缺少参数的情况，而不是等待用户输入：

```python
# ✅ 好的做法 - 优雅处理缺少参数
import sys
if len(sys.argv) < 2:
    print("错误: 缺少版本号参数")
    print("用法: python script.py <version>")
    sys.exit(1)
version = sys.argv[1]

# ❌ 不好的做法 - 等待用户输入
if len(sys.argv) < 2:
    version = input("请输入版本号: ")  # AI无法处理
else:
    version = sys.argv[1]
```

## 部署脚本

**部署脚本：** `scripts/deploy.sh`

此脚本用于部署Flutter应用到目标平台。AI必须使用此脚本进行部署，不得手动执行flutter命令。

**脚本功能：**
- 自动检测连接的设备
- 构建应用
- 安装到设备
- 启动应用

## 禁止行为

- ❌ 手动查找Flutter CLI路径
- ❌ 手动执行Flutter CLI命令（build、run、install等）
- ❌ 手动使用系统命令收集日志
- ❌ 手动访问日志文件路径
- ❌ 不使用预置脚本进行任何调试操作
- ❌ 要求用户手动执行命令
- ❌ 绕过脚本直接操作
- ❌ 脚本失败后不使用脚本，改为手动执行命令
- ❌ 要求用户手动修复脚本
- ❌ 跳过脚本直接操作
- ❌ 不修复脚本而使用临时方案
- ❌ **只提供单一平台的脚本**（必须支持 Windows、macOS、Linux）
- ❌ **使用平台特定的命令而不提供跨平台实现**
- ❌ **硬编码平台特定的路径或命令**
- ❌ **将临时脚本放在 `scripts/` 根目录**（必须放在 `scripts/temp/` 目录）
- ❌ **将临时脚本提交到版本控制**（必须添加到 `.gitignore`）
- ❌ **在脚本中使用交互操作**（如 `input()`、`Read-Host`、`read` 等）
- ❌ **要求用户手动输入参数**（应使用命令行参数、环境变量或配置文件）
- ❌ **使用 `pause`、`select` 等交互式命令**（除非用于调试且可跳过）

## 必须遵守

- ✅ 所有部署必须使用部署脚本
- ✅ 所有日志收集必须使用日志收集脚本
- ✅ 脚本出现问题必须立即修复
- ✅ 修复脚本是AI的责任，不得推给用户
- ✅ 修复后的脚本必须能够正常完成预期功能
- ✅ 修复脚本后必须验证脚本能够正常工作
- ✅ 保持脚本的健壮性和可维护性
- ✅ AI必须主动执行脚本，不要求用户操作
- ✅ **所有脚本必须提供跨平台支持**（Windows、macOS、Linux）
- ✅ **必须提供各平台的入口脚本**（.bat 用于 Windows，.sh 用于 macOS/Linux）
- ✅ **推荐使用跨平台语言（如 Python）实现核心逻辑**，各平台入口脚本调用核心实现
- ✅ **临时脚本必须放在 `scripts/temp/` 目录**，并添加到 `.gitignore`
- ✅ **临时脚本使用完毕后应该及时清理**，如需长期使用应移动到正式脚本目录
- ✅ **所有脚本必须完全非交互式**，使用命令行参数、环境变量或配置文件获取输入
- ✅ **脚本必须提供默认值或清晰的错误提示**，而不是等待用户输入
- ✅ **脚本必须可以被AI自动执行**，无需任何人工干预

## 脚本维护规则（强制）

**如果预置脚本无法完成工作，必须修改脚本使其符合预期正常工作。**

### 脚本问题处理流程

1. **发现问题：** 当脚本执行失败或无法完成预期功能时
2. **分析问题：** 检查脚本错误信息，定位问题原因
3. **修复脚本：** 直接修改脚本文件，使其能够正常工作
4. **验证修复：** 重新执行脚本，确保问题已解决
5. **继续工作：** 使用修复后的脚本继续完成调试任务
